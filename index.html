<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C√°mara Podol√≥gica Asistida (v3)</title>
    <!-- Carga de Tailwind CSS para un dise√±o moderno y responsivo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Fondo oscuro */
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }
        /* Ocultamos el video, solo lo usamos como fuente para el canvas */
        #video-feed {
            display: none;
        }
        /* Contenedor principal que mantiene el aspecto ratio del video */
        #canvas-container {
            width: 100%;
            max-width: 90vh; 
            aspect-ratio: 4/3; 
            position: relative;
            margin-bottom: 1rem;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 1rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            background-color: #000;
            transform-origin: center;
            transition: transform 0.1s ease-out;
        }
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 1rem;
            transition: opacity 0.3s;
        }
        .ai-loading-bar {
            width: 80%;
            height: 8px;
            background-color: #4f46e5;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 1rem;
        }
        .ai-loading-bar::after {
            content: '';
            display: block;
            height: 100%;
            width: 20%;
            background-color: #a5b4fc;
            animation: move-bar 1.5s infinite linear;
        }
        @keyframes move-bar {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(500%); }
        }
    </style>
</head>
<body>

    <h1 class="text-3xl font-bold mb-4 text-indigo-400">C√°mara Podol√≥gica Asistida</h1>

    <div id="canvas-container">
        <canvas id="canvas"></canvas>
        <div id="loading-message" class="loading-overlay">
            <p class="text-xl font-semibold animate-pulse">Cargando c√°maras...</p>
        </div>
    </div>

    <div class="w-full max-w-lg px-4 flex flex-col space-y-3">
        
        <!-- Selector de C√°mara -->
        <label for="camera-select" class="text-sm font-medium text-gray-300">Selecciona el Lente:</label>
        <select id="camera-select" class="p-3 bg-gray-700 border border-gray-600 text-white rounded-lg shadow-md focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out">
            <option>Cargando dispositivos...</option>
        </select>
        
        <!-- Botones de Acci√≥n Principal -->
        <div class="flex space-x-2">
            <!-- Bot√≥n de Inicio/Cambio -->
            <button id="start-button" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-[1.02] active:scale-[0.98] disabled:opacity-50" disabled>
                Iniciar/Cambiar C√°mara
            </button>
            
            <!-- Bot√≥n de Captura de Foto -->
            <button id="capture-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-[1.02] active:scale-[0.98] disabled:opacity-50 flex items-center justify-center" disabled>
                üì∑ Capturar Foto
            </button>
            
            <!-- Bot√≥n de An√°lisis Gemini -->
            <button id="analyze-button" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-[1.02] active:scale-[0.98] disabled:opacity-50 flex items-center justify-center" disabled>
                ‚ú® Analizar Patr√≥n
            </button>
        </div>

        <!-- Botones de Control Visual y Contorno/Medici√≥n -->
        <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 pt-2">
             <!-- Bot√≥n de Espejo -->
            <button id="mirror-button" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-1 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled>
                Espejo OFF
            </button>

             <!-- Bot√≥n de Paleta Inversa -->
            <button id="palette-button" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-1 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled>
                Paleta Normal
            </button>
            
            <!-- Bot√≥n de Contorno -->
            <button id="contour-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-1 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled>
                ‚úèÔ∏è Modo Contorno
            </button>

            <!-- Bot√≥n de Cuadr√≠cula -->
            <button id="grid-button" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-1 rounded-lg shadow-md transition duration-300 ease-in-out disabled:opacity-50" disabled>
                üî≥ Mostrar Cuadr√≠cula
            </button>
        </div>


        <div id="status-message" class="text-center text-sm mt-2 text-red-400 min-h-[1.5rem]"></div>

        <!-- √Årea de Resultados del An√°lisis LLM -->
        <div id="analysis-output" class="hidden mt-4 p-4 bg-gray-800 border-t-4 border-emerald-500 rounded-lg shadow-xl">
            <h3 class="text-xl font-bold mb-2 text-emerald-400">An√°lisis AI del Patr√≥n:</h3>
            <div id="analysis-text" class="text-gray-200 text-sm whitespace-pre-wrap"></div>
            <div id="analysis-spinner" class="hidden mt-3 flex items-center space-x-2 text-emerald-500">
                <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span class="text-sm">Analizando...</span>
            </div>
        </div>
    </div>

    <video id="video-feed" autoplay playsinline></video>

<script>
    const video = document.getElementById('video-feed');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const select = document.getElementById('camera-select');
    const startButton = document.getElementById('start-button');
    const captureButton = document.getElementById('capture-button');
    const analyzeButton = document.getElementById('analyze-button');
    const mirrorButton = document.getElementById('mirror-button');
    const paletteButton = document.getElementById('palette-button');
    const contourButton = document.getElementById('contour-button');
    const gridButton = document.getElementById('grid-button');
    const loadingMessage = document.getElementById('loading-message');
    const statusMessage = document.getElementById('status-message');
    const analysisOutput = document.getElementById('analysis-output');
    const analysisText = document.getElementById('analysis-text');
    const analysisSpinner = document.getElementById('analysis-spinner');
    
    let currentStream = null;
    let availableCameras = [];
    let animationFrameId = null;
    let isMirrored = false; 
    let isPaletteInverted = false; 
    let isContourMode = false; 
    let isGridVisible = false; 
    
    // --- IMPORTANTE: CONFIGURACI√ìN DE LA API KEY ---
    // CLAVE DE API INSERTADA AQU√ç
    const API_KEY = "AIzaSyDR9hbRchIWZVMYPQYMT1nLat0BC40U65E"; 
    const MODEL_NAME = 'gemini-2.5-flash-preview-09-2025';
    // --- FIN CONFIGURACI√ìN DE LA API KEY ---

    // --- Configuraci√≥n de la C√°mara ---

    async function getCameras() {
        statusMessage.textContent = '';
        try {
            await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
            
            const devices = await navigator.mediaDevices.enumerateDevices();
            availableCameras = devices.filter(device => device.kind === 'videoinput');
            
            if (availableCameras.length === 0) {
                statusMessage.textContent = 'No se encontraron dispositivos de c√°mara.';
                return;
            }

            select.innerHTML = '';
            availableCameras.forEach( (device, index) => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                const label = device.label || `C√°mara ${index + 1}`;
                option.textContent = label.includes('facing back') ? `${label} (Trasera)` : label;
                select.appendChild(option);
            });

            startButton.disabled = false;
            loadingMessage.style.display = 'none';

        } catch (error) {
            console.error('Error al acceder a los dispositivos:', error);
            statusMessage.textContent = 'Error: Denegaste el permiso o no hay c√°mara disponible.';
            loadingMessage.style.display = 'none';
        }
    }

    async function startCamera() {
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
            cancelAnimationFrame(animationFrameId);
            currentStream = null;
        }

        const deviceId = select.value;
        if (!deviceId) return;

        loadingMessage.style.display = 'flex';
        statusMessage.textContent = 'Conectando al lente...';
        [startButton, captureButton, analyzeButton, mirrorButton, paletteButton, contourButton, gridButton].forEach(btn => btn.disabled = true);


        const constraints = {
            video: { 
                deviceId: { exact: deviceId } ,
                width: { ideal: 640 }, 
                height: { ideal: 480 }
            },
            audio: false
        };

        try {
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            currentStream = stream;
            video.srcObject = stream;
            
            video.onloadedmetadata = () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                loadingMessage.style.display = 'none';
                statusMessage.textContent = 'C√°mara lista. Lente: ' + select.options[select.selectedIndex].textContent;
                
                [startButton, captureButton, analyzeButton, mirrorButton, paletteButton, contourButton, gridButton].forEach(btn => btn.disabled = false);

                requestAnimationFrame(processFrame);
            };

        } catch (error) {
            console.error('Error al obtener stream:', error);
            statusMessage.textContent = 'Error al iniciar la c√°mara seleccionada. Intenta con otro lente.';
            loadingMessage.style.display = 'none';
            startButton.disabled = false;
        }
    }

    // --- L√≥gica de Filtros ---

    function getThermalColor(grayValue, isInverted) {
        let val = grayValue;
        if (isInverted) {
            val = 255 - grayValue;
        }

        let r, g, b;
        const i = Math.floor(val / 50); 
        const f = (val % 50) / 50; 

        switch (i) {
            case 0:
                r = 0; g = 0; b = 255 * f;
                break;
            case 1:
                r = 0; g = 255 * f; b = 255 * (1 - f);
                break;
            case 2:
                r = 255 * f; g = 255 * (1 - f); b = 0;
                break;
            case 3:
                r = 255; g = 255 * f; b = 0;
                break;
            case 4:
            case 5:
                const whiteFactor = Math.min(1, (val - 200) / 55); 
                r = 255; g = 255; b = 200 + 55 * whiteFactor; 
                break;
            default:
                r = g = b = 0;
        }
        
        return {r: Math.floor(r), g: Math.floor(g), b: Math.floor(b)};
    }
    
    function processContourFrame(imageData) {
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;
        const outputData = new Uint8ClampedArray(data.length);

        const threshold = 20; 

        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const i = (y * width + x) * 4;
                const i_up = ((y - 1) * width + x) * 4;
                const i_down = ((y + 1) * width + x) * 4;
                const i_left = (y * width + (x - 1)) * 4;
                const i_right = (y * width + (x + 1)) * 4;

                const luma = (r, g, b) => (0.2126 * r + 0.7152 * g + 0.0722 * b);

                const center_luma = luma(data[i], data[i+1], data[i+2]);
                const up_luma = luma(data[i_up], data[i_up+1], data[i_up+2]);
                const down_luma = luma(data[i_down], data[i_down+1], data[i_down+2]);
                const left_luma = luma(data[i_left], data[i_left+1], data[i_left+2]);
                const right_luma = luma(data[i_right], data[i_right+1], data[i_right+2]);

                const grad_x = Math.abs(right_luma - left_luma);
                const grad_y = Math.abs(up_luma - down_luma);
                const total_grad = Math.max(grad_x, grad_y);

                let color = 0;
                if (total_grad > threshold) {
                    color = 255;
                }

                outputData[i] = color;
                outputData[i + 1] = color;
                outputData[i + 2] = color;
                outputData[i + 3] = 255;
            }
        }
        
        for (let i = 0; i < data.length; i++) {
            if ((i + 1) % 4 !== 0) {
                data[i] = outputData[i];
            }
        }
    }
    
    function drawGrid(ctx, width, height) {
        if (!isGridVisible) return;

        ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
        ctx.lineWidth = 1;
        
        const numLinesX = 4; 
        const numLinesY = 3;
        
        for (let i = 1; i < numLinesX; i++) {
            const x = (width / numLinesX) * i;
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }

        for (let i = 1; i < numLinesY; i++) {
            const y = (height / numLinesY) * i;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
        
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.moveTo(width / 2, 0);
        ctx.lineTo(width / 2, height);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();
    }


    function processFrame() {
        if (video.paused || video.ended) return;

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        
        if (isContourMode) {
            processContourFrame(imageData);
        } else {
            const data = imageData.data;
            const length = data.length;
            for (let i = 0; i < length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                const gray = (0.2126 * r + 0.7152 * g + 0.0722 * b); 
                const color = getThermalColor(gray, isPaletteInverted); 

                data[i] = color.r;
                data[i + 1] = color.g;
                data[i + 2] = color.b;
            }
        }
        
        ctx.putImageData(imageData, 0, 0);

        drawGrid(ctx, canvas.width, canvas.height); 

        animationFrameId = requestAnimationFrame(processFrame);
    }
    
    // --- L√≥gica de Captura y Control Visual ---

    function capturePhoto() {
        if (canvas.width === 0 || canvas.height === 0) {
            statusMessage.textContent = 'Error: No hay c√°mara activa para capturar.';
            return;
        }
        
        const dataURL = canvas.toDataURL('image/png');
        const a = document.createElement('a');
        
        const date = new Date();
        const filename = `Pisada_Termica_${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}_${date.getHours().toString().padStart(2, '0')}${date.getMinutes().toString().padStart(2, '0')}${date.getSeconds().toString().padStart(2, '0')}.png`;
        
        a.href = dataURL;
        a.download = filename;
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        statusMessage.textContent = `Foto capturada: ${filename}. B√∫scala en tu carpeta de descargas.`;
        
        canvas.style.filter = 'brightness(0.8)';
        setTimeout(() => { canvas.style.filter = 'brightness(1)'; }, 200);
    }

    function toggleMirror() {
        isMirrored = !isMirrored;
        if (isMirrored) {
            canvas.style.transform = 'scaleX(-1)';
            mirrorButton.textContent = 'Espejo ON';
            mirrorButton.classList.remove('bg-gray-600');
            mirrorButton.classList.add('bg-gray-800');
        } else {
            canvas.style.transform = 'scaleX(1)';
            mirrorButton.textContent = 'Espejo OFF';
            mirrorButton.classList.remove('bg-gray-800');
            mirrorButton.classList.add('bg-gray-600');
        }
    }

    function togglePalette() {
        isPaletteInverted = !isPaletteInverted;
        if (isPaletteInverted) {
            paletteButton.textContent = 'Paleta Inversa ON';
            paletteButton.classList.remove('bg-purple-600');
            paletteButton.classList.add('bg-purple-800');
        } else {
            paletteButton.textContent = 'Paleta Normal';
            paletteButton.classList.remove('bg-purple-800');
            paletteButton.classList.add('bg-purple-600');
        }
    }
    
    function toggleContour() {
        isContourMode = !isContourMode;
        if (isContourMode) {
            contourButton.textContent = 'Modo Contorno ON';
            contourButton.classList.remove('bg-red-600');
            contourButton.classList.add('bg-red-800');
            paletteButton.disabled = true;
            paletteButton.classList.add('opacity-50');
        } else {
            contourButton.textContent = '‚úèÔ∏è Modo Contorno';
            contourButton.classList.remove('bg-red-800');
            contourButton.classList.add('bg-red-600');
            paletteButton.disabled = false;
            paletteButton.classList.remove('opacity-50');
        }
    }
    
    function toggleGrid() {
        isGridVisible = !isGridVisible;
        if (isGridVisible) {
            gridButton.textContent = 'Cuadr√≠cula ON';
            gridButton.classList.remove('bg-yellow-600');
            gridButton.classList.add('bg-yellow-800');
        } else {
            gridButton.textContent = 'üî≥ Mostrar Cuadr√≠cula';
            gridButton.classList.remove('bg-yellow-800');
            gridButton.classList.add('bg-yellow-600');
        }
    }


    // --- L√≥gica de Integraci√≥n con Gemini (LLM) ---
    
    /**
     * Llama a la API de Gemini con la imagen capturada para an√°lisis.
     */
    async function callGeminiAPI(base64Image) {
        analysisOutput.classList.remove('hidden');
        analysisText.textContent = '';
        analysisSpinner.classList.remove('hidden');
        
        if (API_KEY === "") {
            analysisSpinner.classList.add('hidden');
            analysisText.textContent = "Error 403: API Key ausente. Por favor, pega tu llave real en la variable 'API_KEY' dentro del c√≥digo.";
            [startButton, captureButton, analyzeButton, mirrorButton, paletteButton, contourButton, gridButton].forEach(btn => btn.disabled = false);
            return;
        }

        [startButton, captureButton, analyzeButton, mirrorButton, paletteButton, contourButton, gridButton].forEach(btn => btn.disabled = true);

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${API_KEY}`;
        
        let pressureInterpretation = "";
        if (isContourMode) {
            pressureInterpretation = "La imagen est√° en Modo Contorno (blanco y negro). El blanco indica bordes de alta variaci√≥n de luz/presi√≥n, mientras que el negro es el fondo o √°reas uniformes.";
        } else {
             pressureInterpretation = isPaletteInverted 
                ? "La paleta est√° INVERTIDA. El blanco/amarillo representa BAJA presi√≥n (poca luz) y el azul/negro representa ALTA presi√≥n (mucha luz)."
                : "La paleta est√° NORMAL. El blanco/amarillo representa ALTA presi√≥n (mucha luz) y el azul/negro representa BAJA presi√≥n (poca luz, como el arco plantar).";
        }
        
        const systemPrompt = `Eres un experto en an√°lisis de im√°genes de huellas plantares. Tu tarea es describir la huella plantar visible.
        
        Reglas de interpretaci√≥n de la imagen:
        ${pressureInterpretation}

        Describe la forma general de la huella, la distribuci√≥n de la presi√≥n (bas√°ndote en las reglas anteriores), y cualquier caracter√≠stica visible que pueda indicar un pie plano, cavo, o una distribuci√≥n normal de la carga. Responde en espa√±ol de forma concisa.`;
        
        const userQuery = "Analiza esta imagen de huella plantar.";
        
        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: userQuery },
                        {
                            inlineData: {
                                mimeType: "image/png",
                                data: base64Image
                            }
                        }
                    ]
                }
            ],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            },
        };

        let resultText = "Error: No se pudo obtener la respuesta.";
        
        for (let attempt = 0; attempt < 5; attempt++) {
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorStatus = response.status;
                    throw new Error(`HTTP error! status ${errorStatus}`);
                }
                
                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    resultText = candidate.content.parts[0].text;
                    break; 
                } else {
                    throw new Error("Respuesta del modelo incompleta o vac√≠a.");
                }

            } catch (error) {
                console.error(`Intento ${attempt + 1}: Error al llamar a la API de Gemini:`, error);
                if (attempt === 4) {
                    resultText = `Error al conectar o procesar la imagen con Gemini. Intenta de nuevo: ${error.message}`;
                }
                await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000)); 
            }
        }
        
        analysisSpinner.classList.add('hidden');
        analysisText.textContent = resultText;
        [startButton, captureButton, analyzeButton, mirrorButton, paletteButton, contourButton, gridButton].forEach(btn => btn.disabled = false);
        if (isContourMode) paletteButton.disabled = true;
    }

    function captureAndAnalyze() {
        if (canvas.width === 0 || canvas.height === 0) {
            analysisText.textContent = "Error: La c√°mara no est√° activa o el canvas est√° vac√≠o.";
            analysisOutput.classList.remove('hidden');
            return;
        }

        const dataURL = canvas.toDataURL('image/png');
        const base64Image = dataURL.split(',')[1];
        callGeminiAPI(base64Image);
    }

    // --- Inicializaci√≥n y Eventos ---
    
    window.onload = getCameras;
    startButton.addEventListener('click', startCamera);
    captureButton.addEventListener('click', capturePhoto); 
    analyzeButton.addEventListener('click', captureAndAnalyze);
    mirrorButton.addEventListener('click', toggleMirror); 
    paletteButton.addEventListener('click', togglePalette); 
    contourButton.addEventListener('click', toggleContour);
    gridButton.addEventListener('click', toggleGrid);

</script>
</body>
</html>
